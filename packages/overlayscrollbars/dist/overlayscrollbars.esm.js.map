{"version":3,"file":"overlayscrollbars.esm.js","sources":["../src/support/utils/types.ts","../src/support/utils/object.ts","../src/support/utils/array.ts","../src/support/dom/traversal.ts","../src/support/dom/manipulation.ts","../src/support/dom/create.ts","../src/index.ts"],"sourcesContent":["import { PlainObject } from 'typings';\r\n\r\nexport const type: (obj: any) => string = (obj) => {\r\n  if (obj === undefined) return `${obj}`;\r\n  if (obj === null) return `${obj}`;\r\n  return Object.prototype.toString\r\n    .call(obj)\r\n    .replace(/^\\[object (.+)\\]$/, '$1')\r\n    .toLowerCase();\r\n};\r\n\r\nexport function isNumber(obj: any): obj is number {\r\n  return typeof obj === 'number';\r\n}\r\n\r\nexport function isString(obj: any): obj is string {\r\n  return typeof obj === 'string';\r\n}\r\n\r\nexport function isBoolean(obj: any): obj is boolean {\r\n  return typeof obj === 'boolean';\r\n}\r\n\r\nexport function isFunction(obj: any): obj is (...args: Array<unknown>) => unknown {\r\n  return typeof obj === 'function';\r\n}\r\n\r\nexport function isUndefined(obj: any): obj is undefined {\r\n  return obj === undefined;\r\n}\r\n\r\nexport function isNull(obj: any): obj is null {\r\n  return obj === null;\r\n}\r\n\r\nexport function isArray(obj: any): obj is Array<any> {\r\n  return Array.isArray(obj);\r\n}\r\n\r\nexport function isObject(obj: any): boolean {\r\n  return typeof obj === 'object' && !isArray(obj) && !isNull(obj);\r\n}\r\n\r\n/**\r\n * Returns true if the given object is array like, false otherwise.\r\n * @param obj The Object\r\n */\r\nexport function isArrayLike<T extends PlainObject = any>(obj: any): obj is ArrayLike<T> {\r\n  const length = !!obj && obj.length;\r\n  return isArray(obj) || (!isFunction(obj) && isNumber(length) && length > -1 && length % 1 == 0); // eslint-disable-line eqeqeq\r\n}\r\n\r\n/**\r\n * Returns true if the given object is a \"plain\" (e.g. { key: value }) object, false otherwise.\r\n * @param obj The Object.\r\n */\r\nexport function isPlainObject<T = any>(obj: any): obj is PlainObject<T> {\r\n  if (!obj || !isObject(obj) || type(obj) !== 'object') return false;\r\n\r\n  let key;\r\n  const proto = 'prototype';\r\n  const { hasOwnProperty } = Object[proto];\r\n  const hasOwnConstructor = hasOwnProperty.call(obj, 'constructor');\r\n  const hasIsPrototypeOf = obj.constructor && obj.constructor[proto] && hasOwnProperty.call(obj.constructor[proto], 'isPrototypeOf');\r\n\r\n  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\r\n    return false;\r\n  }\r\n\r\n  /* eslint-disable no-restricted-syntax */\r\n  for (key in obj) {\r\n    /**/\r\n  }\r\n  /* eslint-enable */\r\n\r\n  return isUndefined(key) || hasOwnProperty.call(obj, key);\r\n}\r\n\r\n/**\r\n * Checks whether the given object is a HTMLElement.\r\n * @param obj The object which shall be checked.\r\n */\r\nexport function isHTMLElement(obj: any): obj is HTMLElement {\r\n  const instaceOfRightHandSide = window.HTMLElement;\r\n  const doInstanceOf = isObject(instaceOfRightHandSide) || isFunction(instaceOfRightHandSide);\r\n  return !!(doInstanceOf ? obj instanceof instaceOfRightHandSide : obj && isObject(obj) && obj.nodeType === 1 && isString(obj.nodeName));\r\n}\r\n\r\n/**\r\n * Returns true if the given object is empty, false otherwise.\r\n * @param obj The Object.\r\n */\r\nexport function isEmptyObject(obj: any): boolean {\r\n  /* eslint-disable no-restricted-syntax, guard-for-in */\r\n  for (const name in obj) return false;\r\n  return true;\r\n  /* eslint-enable */\r\n}\r\n","/**\r\n * Determines whether the passed object has a property with the passed name.\r\n * @param obj The object.\r\n * @param prop The name of the property.\r\n */\r\nexport const hasOwnProperty = (obj: any, prop: string | number | symbol): boolean =>\r\n  Object.prototype.hasOwnProperty.call(obj, prop);\r\n\r\n/**\r\n * Returns the names of the enumerable string properties and methods of an object.\r\n * @param obj The object of which the properties shall be returned.\r\n */\r\nexport const keys = (obj: any): Array<string> => (obj ? Object.keys(obj) : []);\r\n","import { keys } from 'support/utils/object';\r\nimport { isArrayLike } from 'support/utils/types';\r\nimport { PlainObject } from 'typings';\r\n\r\n/**\r\n * Iterates through a array or object\r\n * @param arrayLikeOrObject The array or object through which shall be iterated.\r\n * @param callback The function which is responsible for the iteration.\r\n * If the function returns true its treated like a \"continue\" statement.\r\n * If the function returns false its treated like a \"break\" statement.\r\n */\r\nexport function each<T>(\r\n  array: Array<T> | ReadonlyArray<T>,\r\n  callback: (value: T, indexOrKey: number, source: Array<T>) => boolean | void,\r\n): Array<T> | ReadonlyArray<T>;\r\nexport function each<T>(\r\n  array: Array<T> | ReadonlyArray<T> | null,\r\n  callback: (value: T, indexOrKey: number, source: Array<T>) => boolean | void,\r\n): Array<T> | ReadonlyArray<T> | null;\r\nexport function each<T>(\r\n  arrayLikeObject: ArrayLike<T>,\r\n  callback: (value: T, indexOrKey: number, source: ArrayLike<T>) => boolean | void,\r\n): ArrayLike<T>;\r\nexport function each<T>(\r\n  arrayLikeObject: ArrayLike<T> | null,\r\n  callback: (value: T, indexOrKey: number, source: ArrayLike<T>) => boolean | void,\r\n): ArrayLike<T> | null;\r\nexport function each(obj: PlainObject, callback: (value: any, indexOrKey: string, source: PlainObject) => boolean | void): PlainObject;\r\nexport function each(obj: PlainObject | null, callback: (value: any, indexOrKey: string, source: PlainObject) => boolean | void): PlainObject | null;\r\nexport function each<T>(\r\n  source: ArrayLike<T> | PlainObject | null,\r\n  callback: (value: T | any, indexOrKey: any, source: any) => boolean | void,\r\n): Array<T> | ReadonlyArray<T> | ArrayLike<T> | PlainObject | null {\r\n  if (isArrayLike(source)) {\r\n    for (let i = 0; i < source.length; i++) {\r\n      if (callback(source[i], i, source) === false) {\r\n        break;\r\n      }\r\n    }\r\n  } else if (source) {\r\n    each(keys(source), (key) => callback(source[key], key, source));\r\n  }\r\n  return source;\r\n}\r\n\r\n/**\r\n * Returns the index of the given inside the given array or -1 if the given item isn't part of the given array.\r\n * @param arr The array.\r\n * @param item The item.\r\n * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\r\n */\r\nexport const indexOf = <T = any>(arr: Array<T>, item: T, fromIndex?: number): number => arr.indexOf(item, fromIndex);\r\n","import { each } from 'support/utils/array';\r\n\r\nconst elementIsVisible = (elm: HTMLElement): boolean => !!(elm.offsetWidth || elm.offsetHeight || elm.getClientRects().length);\r\n\r\nexport const find = (selector: string, elm?: Element | null): ReadonlyArray<Element> => {\r\n  const arr: Array<Element> = [];\r\n\r\n  each((elm || document).querySelectorAll(selector), (e: Element) => {\r\n    arr.push(e);\r\n  });\r\n\r\n  return arr;\r\n};\r\n\r\nexport const findFirst = (selector: string, elm?: Element | null): Element | null => (elm || document).querySelector(selector);\r\n\r\nexport const is = (elm: Element | null, selector: string): boolean => {\r\n  if (elm) {\r\n    if (selector === ':visible') {\r\n      return elementIsVisible(elm as HTMLElement);\r\n    }\r\n    if (selector === ':hidden') {\r\n      return !elementIsVisible(elm as HTMLElement);\r\n    }\r\n    if (elm.matches(selector)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nexport const children = (elm: Element | null, selector?: string): ReadonlyArray<Element> => {\r\n  const childs: Array<Element> = [];\r\n\r\n  each(elm && elm.children, (child: Element) => {\r\n    if (selector) {\r\n      if (child.matches(selector)) {\r\n        childs.push(child);\r\n      }\r\n    } else {\r\n      childs.push(child);\r\n    }\r\n  });\r\n\r\n  return childs;\r\n};\r\n\r\nexport const contents = (elm: Element | null): ReadonlyArray<ChildNode> => (elm ? Array.from<ChildNode>(elm.childNodes) : []);\r\n\r\nexport const parent = (elm: Node | null): Node | null => (elm ? elm.parentElement : null);\r\n","import { isArrayLike } from 'support/utils/types';\r\nimport { each } from 'support/utils/array';\r\nimport { parent } from 'support/dom/traversal';\r\n\r\ntype NodeCollection = ArrayLike<Node> | Node | undefined | null;\r\n\r\n/**\r\n * Inserts Nodes before the given preferredAnchor element.\r\n * @param parentElm The parent of the preferredAnchor element or the element which shall be the parent of the inserted Nodes.\r\n * @param preferredAnchor The element before which the Nodes shall be inserted or null if the elements shall be appended at the end.\r\n * @param insertedElms The Nodes which shall be inserted.\r\n */\r\nconst before = (parentElm: Node | null, preferredAnchor: Node | null, insertedElms: NodeCollection): void => {\r\n  if (insertedElms) {\r\n    let anchor: Node | null = preferredAnchor;\r\n    let fragment: DocumentFragment | Node | undefined | null;\r\n\r\n    // parent must be defined\r\n    if (parentElm) {\r\n      if (isArrayLike(insertedElms)) {\r\n        fragment = document.createDocumentFragment();\r\n\r\n        // append all insertedElms to the fragment and if one of these is the anchor, change the anchor\r\n        each(insertedElms, (insertedElm) => {\r\n          if (insertedElm === anchor) {\r\n            anchor = insertedElm.previousSibling;\r\n          }\r\n          fragment!.appendChild(insertedElm);\r\n        });\r\n      } else {\r\n        fragment = insertedElms;\r\n      }\r\n\r\n      // if the preferred anchor isn't null set it to a valid anchor\r\n      if (preferredAnchor) {\r\n        if (!anchor) {\r\n          anchor = parentElm.firstChild;\r\n        } else if (anchor !== preferredAnchor) {\r\n          anchor = anchor.nextSibling;\r\n        }\r\n      }\r\n\r\n      parentElm.insertBefore(fragment, anchor);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Appends the given children at the end of the given Node.\r\n * @param node The Node to which the children shall be appended.\r\n * @param children The Nodes which shall be appended.\r\n */\r\nexport const appendChildren = (node: Node | null, children: NodeCollection): void => {\r\n  before(node, null, children);\r\n};\r\n\r\n/**\r\n * Prepends the given children at the start of the given Node.\r\n * @param node The Node to which the children shall be prepended.\r\n * @param children The Nodes which shall be prepended.\r\n */\r\nexport const prependChildren = (node: Node | null, children: NodeCollection): void => {\r\n  before(node, node && node.firstChild, children);\r\n};\r\n\r\n/**\r\n * Inserts the given Nodes before the given Node.\r\n * @param node The Node before which the given Nodes shall be inserted.\r\n * @param insertedNodes The Nodes which shall be inserted.\r\n */\r\nexport const insertBefore = (node: Node | null, insertedNodes: NodeCollection): void => {\r\n  before(parent(node), node, insertedNodes);\r\n};\r\n\r\n/**\r\n * Inserts the given Nodes after the given Node.\r\n * @param node The Node after which the given Nodes shall be inserted.\r\n * @param insertedNodes The Nodes which shall be inserted.\r\n */\r\nexport const insertAfter = (node: Node | null, insertedNodes: NodeCollection): void => {\r\n  before(parent(node), node && node.nextSibling, insertedNodes);\r\n};\r\n\r\n/**\r\n * Removes the given Nodes from their parent.\r\n * @param nodes The Nodes which shall be removed.\r\n */\r\nexport const removeElements = (nodes: NodeCollection): void => {\r\n  if (isArrayLike(nodes)) {\r\n    each(Array.from(nodes), (e) => removeElements(e));\r\n  } else if (nodes) {\r\n    const { parentNode } = nodes;\r\n    if (parentNode) {\r\n      parentNode.removeChild(nodes);\r\n    }\r\n  }\r\n};\r\n","import { each } from 'support/utils/array';\r\nimport { contents } from 'support/dom/traversal';\r\nimport { removeElements } from 'support/dom/manipulation';\r\n\r\nexport const createDiv = (): HTMLDivElement => document.createElement('div');\r\n\r\nexport const createDOM = (html: string): ReadonlyArray<Node> => {\r\n  const createdDiv = createDiv();\r\n  createdDiv.innerHTML = html.trim();\r\n\r\n  return each(contents(createdDiv), (elm) => removeElements(elm));\r\n};\r\n","import { createDOM } from 'support/dom';\r\n\r\nconst abc = {\r\n  a: 1,\r\n  b: 1,\r\n  c: 1,\r\n};\r\n\r\nexport default () => {\r\n  const { a, b, c } = abc;\r\n  return [\r\n    createDOM(\r\n      '\\\r\n    <div class=\"os-host\">\\\r\n        <div class=\"os-resize-observer-host\"></div>\\\r\n        <div class=\"os-padding\">\\\r\n            <div class=\"os-viewport\">\\\r\n                <div class=\"os-content\">\\\r\n                    fdfhdfgh\\\r\n                </div>\\\r\n            </div>\\\r\n        </div>\\\r\n        <div class=\"os-scrollbar os-scrollbar-horizontal\">\\\r\n            <div class=\"os-scrollbar-track\">\\\r\n                <div class=\"os-scrollbar-handle\"></div>\\\r\n            </div>\\\r\n        </div>\\\r\n        <div class=\"os-scrollbar os-scrollbar-vertical\">\\\r\n            <div class=\"os-scrollbar-track\">\\\r\n                <div class=\"os-scrollbar-handle\"></div>\\\r\n            </div>\\\r\n        </div>\\\r\n        <div class=\"os-scrollbar-corner\"></div>\\\r\n    </div>'\r\n    ),\r\n    a,\r\n    b,\r\n    c,\r\n  ];\r\n};\r\n"],"names":["isNumber","obj","isFunction","isArray","Array","isArrayLike","length","keys","Object","each","source","callback","i","key","contents","elm","from","childNodes","removeElements","nodes","e","parentNode","removeChild","createDiv","document","createElement","createDOM","html","createdDiv","innerHTML","trim","abc","a","b","c"],"mappings":"SAWgBA,SAASC;AACvB,SAAO,OAAOA,GAAP,KAAe,QAAtB;AACD;;SAUeC,WAAWD;AACzB,SAAO,OAAOA,GAAP,KAAe,UAAtB;AACD;;SAUeE,QAAQF;AACtB,SAAOG,KAAK,CAACD,OAAN,CAAcF,GAAd,CAAP;AACD;;SAUeI,YAAyCJ;AACvD,QAAMK,MAAM,GAAG,CAAC,CAACL,GAAF,IAASA,GAAG,CAACK,MAA5B;AACA,SAAOH,OAAO,CAACF,GAAD,CAAP,KAAiB,CAACC,UAAU,CAACD,GAAD,CAAX,IAAoBD,QAAQ,CAACM,MAAD,CAA5B,IAAwCA,MAAM,GAAG,CAAC,CAAlD,IAAuDA,MAAM,GAAG,CAAT,IAAc,EAA7F;;;ACrCK,MAAMC,IAAI,IAAIN,IAAD,KAA8BA,GAAG,GAAGO,MAAM,CAACD,IAAP,CAAYN,GAAZ,CAAH,GAAsB,GAApE;;SCiBSQ,KACdC,QACAC;AAEA,MAAIN,WAAW,CAACK,MAAD,CAAf,EAAyB;AACvB,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAACJ,MAA3B,EAAmCM,CAAC,EAApC,EAAwC;AACtC,UAAID,QAAQ,CAACD,MAAM,CAACE,CAAD,CAAP,EAAYA,CAAZ,EAAeF,MAAf,CAAR,KAAmC,KAAvC,EAA8C;AAC5C;AACD;AACF;AACF,GAND,MAMO,IAAIA,MAAJ,EAAY;AACjBD,IAAAA,IAAI,CAACF,IAAI,CAACG,MAAD,CAAL,GAAgBG,IAAD,IAASF,QAAQ,CAACD,MAAM,CAACG,GAAD,CAAP,EAAcA,GAAd,EAAmBH,MAAnB,CAAhC,CAAJ;AACD;;AACD,SAAOA,MAAP;;;ACKK,MAAMI,QAAQ,IAAIC,IAAD,KAAoDA,GAAG,GAAGX,KAAK,CAACY,IAAN,CAAsBD,GAAG,CAACE,UAA1B,CAAH,GAA2C,GAAnH;;ACwCA,MAAMC,cAAc,IAAIC,MAAD;AAC5B,MAAId,WAAW,CAACc,KAAD,CAAf,EAAwB;AACtBV,IAAAA,IAAI,CAACL,KAAK,CAACY,IAAN,CAAWG,KAAX,CAAD,GAAqBC,EAAD,IAAOF,cAAc,CAACE,CAAD,CAAzC,CAAJ;AACD,GAFD,MAEO,IAAID,KAAJ,EAAW;AAChB,UAAM,CAAEE,CAAAA,UAAF,KAAiBF,KAAvB;;AACA,QAAIE,UAAJ,EAAgB;AACdA,MAAAA,UAAU,CAACC,WAAX,CAAuBH,KAAvB;AACD;AACF;AACF,CATM;;ACnFA,MAAMI,SAAS,GAAG,MAAsBC,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAxC;;AAEA,MAAMC,SAAS,IAAIC,KAAD;AACvB,QAAMC,UAAU,GAAGL,SAAS,EAA5B;AACAK,EAAAA,UAAU,CAACC,SAAX,GAAuBF,IAAI,CAACG,IAAL,EAAvB;AAEA,SAAOrB,IAAI,CAACK,QAAQ,CAACc,UAAD,CAAT,GAAwBb,IAAD,IAASG,cAAc,CAACH,GAAD,CAA9C,CAAX;AACD,CALM;;ACJP,MAAMgB,GAAG,GAAG;AACVC,EAAAA,CAAC,EAAE,CADO;AAEVC,EAAAA,CAAC,EAAE,CAFO;AAGVC,EAAAA,CAAC,EAAE;AAHO,CAAZ;;AAMA,YAAe;AACb,QAAM,CAAEF,CAAAA,CAAF,CAAKC,CAAAA,CAAL,CAAQC,CAAAA,CAAR,KAAcH,GAApB;AACA,SAAO;IACLL,SAAS;MACP;;;;;;;;;;;;;;;;;;;;;;IADO,CADJ;IAyBLM,CAzBK;IA0BLC,CA1BK;IA2BLC;EA3BK,CAAP;AA6BD,CA/BD;;;"}