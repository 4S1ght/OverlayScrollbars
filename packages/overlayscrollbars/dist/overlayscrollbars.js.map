{"version":3,"sources":["webpack://OverlayScrollbars/webpack/universalModuleDefinition","webpack://OverlayScrollbars/./packages/overlayscrollbars/src/core/utils/types.ts","webpack://OverlayScrollbars/./packages/overlayscrollbars/src/core/utils/arrays.ts","webpack://OverlayScrollbars/./packages/overlayscrollbars/src/core/dom/manipulation.ts","webpack://OverlayScrollbars/./packages/overlayscrollbars/src/core/dom/create.ts","webpack://OverlayScrollbars/./packages/overlayscrollbars/src/core/dom/traversal.ts","webpack://OverlayScrollbars/./packages/overlayscrollbars/src/core/compatibility/vendors.ts","webpack://OverlayScrollbars/./packages/overlayscrollbars/src/core/options/validation.ts","webpack://OverlayScrollbars/./packages/overlayscrollbars/src/core/compatibility/apis.ts","webpack://OverlayScrollbars/./packages/overlayscrollbars/src/instances.ts","webpack://OverlayScrollbars/./packages/overlayscrollbars/src/index.ts","webpack://OverlayScrollbars/webpack/bootstrap","webpack://OverlayScrollbars/webpack/startup","webpack://OverlayScrollbars/webpack/runtime/define property getters","webpack://OverlayScrollbars/webpack/runtime/hasOwnProperty shorthand"],"names":["root","factory","exports","module","define","amd","window","isFunction","obj","isArray","Array","isArrayLike","length","isNumber","each","source","callback","i","removeElements","nodes","from","e","parentNode","removeChild","createDOM","html","elm","document","createElement","innerHTML","trim","childNodes","contents","name","result","firstLetterToUpper","str","charAt","toUpperCase","slice","jsPrefixes","jsCache","templateTypePrefixSuffix","hasOwnProperty","prefix","JSON","stringify","reduce","item","Set","WeakMap","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","prop","prototype","call"],"mappings":"CAAA,SAA2CA,GAAMC;IAC1B,mBAAZC,WAA0C,mBAAXC,SACxCA,OAAOD,UAAUD,MACQ,qBAAXG,UAAyBA,OAAOC,MAC9CD,OAAO,IAAIH,KACe,mBAAZC,UACdA,QAA2B,oBAAID,MAE/BD,EAAwB,oBAAIC;CAR9B,CASGK,SAAQ;IACX,O;;;;;;;;;gBCgBO,SAASC,EAAWC;oBACvB,OAAsB,qBAARA;;gBAWX,SAASC,EAAQD;oBACpB,OAAOE,MAAMD,QAAQD;;gBAQlB,SAASG,EAAyCH;oBACrD,IAAMI,MAAWJ,KAAOA,EAAII;oBAC5B,OAAOH,EAAQD,OAAUD,EAAWC,MAvCjC,SAAkBA;wBACrB,OAAsB,mBAARA;qBAsC8BK,CAASD,MAAWA,KAAU,KAAKA,IAAS,KAAK;;gBChC1F,SAASE,EAAQC,GAA2CC;oBAC/D,IAAIC,IAAqB;oBAEzB,IAAIN,EAAYI,IACZ,MAAOE,IAAIF,EAAOH,WACyB,MAAnCI,EAASD,EAAOE,IAAIA,GAAGF,IADLE,YAKzB,IAAIF,GACL,KAAKE,KAAKF,GACN,KAAuC,MAAnCC,EAASD,EAAOE,IAAIA,GAAGF,IACvB;oBAGZ,OAAOA;;gBASJ,ICwCMG,IAAkD,SAACC;oBAC5D,IAAIR,EAAYQ,IACZL,EAAKJ,MAAMU,KAAKD,KAAQ,SAACE;wBAAM,OAAAH,EAAeG;8BAE7C,IAAIF,GAAO;wBACZ,IAAMG,IAAaH,EAAMG;wBACrBA,KACAA,EAAWC,YAAYJ;;mBChFtBK,IAAmD,SAACC;oBAC7D,IAAMC,IAJCC,SAASC,cAAc;oBAO9B,OAFAF,EAAIG,YAAYJ,EAAKK,QAEdhB,ECmCgE,SAACY;wBACxE,OAAOA,IAAMhB,MAAMU,KAAgBM,EAAIK,cAAc;qBDpCzCC,CAASN,KAAM,SAACA;wBAAQ,OAAAR,EAAeQ;;;gBETvD,IAkF6CO,GACrCC,GAnFFC,IAA8C,SAACC;oBACjD,OAAOA,EAAIC,OAAO,GAAGC,gBAAgBF,EAAIG,MAAM;mBAStCC,IAAoC,EAAC,UAAU,OAAO,KAAK,MAAM,UAAU,OAAO,KAAK,QAEvFC,IAAkC,ICNzCC,KD6EER,IAAcO,EADuBR,IEnFQ,qBFoFd3B,OAAO2B;gBAEtCQ,EAAQE,eAAeV,OAG3BnB,EAAK0B,IAAY,SAACI;oBAEd,SADAV,IAASA,KAAU5B,OAAOsC,IAAST,EAAmBF;qBAI1DQ,EAAQR,KAAQC,IC5FFW,KAAKC,WAKqC,EAAC,UAAU;gBAMV,EACzD,WACA,UACA,UACA,SACA,UACA,YACA,SACFC,QAAO,SAACb,GAAQc;oBAEd,OADAd,EAAOc,KAAQN,EAAyB,KAAKM,IAAON,EAAyB,IACtER;oBACR;gBE1B2B,IAAIe,KACe,IAAIC;gBADrD,ICWA;oBAAqB,OAAA1B,EAAU;;;WCV3B2B,IAA2B;QAG/B,SAASC,EAAoBC;YAE5B,IAAGF,EAAyBE,IAC3B,OAAOF,EAAyBE,GAAUnD;YAG3C,IAAIC,IAASgD,EAAyBE,KAAY;gBAGjDnD,SAAS;;YAOV,OAHAoD,EAAoBD,GAAUlD,GAAQA,EAAOD,SAASkD,IAG/CjD,EAAOD;;QCjBf,OCFAkD,EAAoBG,IAAI,SAASrD,GAASsD;YACzC,KAAI,IAAIC,KAAOD,GACXJ,EAAoBM,EAAEF,GAAYC,OAASL,EAAoBM,EAAExD,GAASuD,MAC5EE,OAAOC,eAAe1D,GAASuD,GAAK;gBAAEI,aAAY;gBAAMC,KAAKN,EAAWC;;WCJ3EL,EAAoBM,IAAI,SAASlD,GAAKuD;YAAQ,OAAOJ,OAAOK,UAAUrB,eAAesB,KAAKzD,GAAKuD;WFGxFX,EAAoB","file":"overlayscrollbars.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OverlayScrollbars\"] = factory();\n\telse\n\t\troot[\"OverlayScrollbars\"] = factory();\n})(window, function() {\nreturn ","import { PlainObject } from 'core/typings';\r\n\r\nexport const type: (obj: any) => string = (obj) => {\r\n    if (obj === undefined)\r\n        return obj + '';\r\n    if (obj === null)\r\n        return obj + '';\r\n    return Object.prototype.toString.call(obj).replace(/^\\[object (.+)\\]$/, '$1').toLowerCase();\r\n}\r\n\r\nexport function isNumber(obj: any): obj is number {\r\n    return typeof obj === 'number';\r\n};\r\n\r\nexport function isString(obj: any): obj is string {\r\n    return typeof obj === 'string';\r\n}\r\n\r\nexport function isBoolean(obj: any): obj is boolean {\r\n    return typeof obj === 'boolean';\r\n}\r\n\r\nexport function isObject(obj: any): boolean {\r\n    return typeof obj === 'object' && !isArray(obj) && !isNull(obj);\r\n}\r\n\r\nexport function isFunction(obj: any): obj is Function {\r\n    return typeof obj === 'function';\r\n}\r\n\r\nexport function isUndefined(obj: any): obj is undefined {\r\n    return obj === undefined;\r\n}\r\n\r\nexport function isNull(obj: any): obj is null {\r\n    return obj === null;\r\n}\r\n\r\nexport function isArray(obj: any): obj is Array<any> {\r\n    return Array.isArray(obj);\r\n}\r\n\r\n\r\n/**\r\n * Returns true if the given object is array like, false otherwise.\r\n * @param obj The Object\r\n */\r\nexport function isArrayLike<T extends PlainObject = any>(obj: any): obj is ArrayLike<T> {\r\n    const length = !!obj && obj.length;\r\n    return isArray(obj) || (!isFunction(obj) && isNumber(length) && length > -1 && length % 1 == 0);\r\n}\r\n\r\n/**\r\n * Returns true if the given object is a \"plain\" (e.g. { key: value }) object, false otherwise. \r\n * @param obj The Object.\r\n */\r\nexport function isPlainObject<T = any>(obj: any): obj is PlainObject<T> {\r\n    if (!obj || !isObject(obj) || type(obj) !== 'object')\r\n        return false;\r\n\r\n    let key;\r\n    const proto = 'prototype';\r\n    const hasOwnProperty = Object[proto].hasOwnProperty;\r\n    const hasOwnConstructor = hasOwnProperty.call(obj, 'constructor');\r\n    const hasIsPrototypeOf = obj.constructor && obj.constructor[proto] && hasOwnProperty.call(obj.constructor[proto], 'isPrototypeOf');\r\n\r\n    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\r\n        return false;\r\n    }\r\n\r\n    for (key in obj) { /**/ }\r\n\r\n    return isUndefined(key) || hasOwnProperty.call(obj, key);\r\n};\r\n\r\n/**\r\n * Checks whether the given object is a HTMLElement.\r\n * @param obj The object which shall be checked.\r\n */\r\nexport function isHTMLElement(obj: any): obj is HTMLElement {\r\n    const instaceOfRightHandSide = window.HTMLElement;\r\n    const doInstanceOf = isObject(instaceOfRightHandSide) || isFunction(instaceOfRightHandSide);\r\n    return !!(\r\n        doInstanceOf ? obj instanceof instaceOfRightHandSide : (obj && isObject(obj) && obj.nodeType === 1 && isString(obj.nodeName))\r\n    );\r\n}\r\n\r\n/**\r\n * Returns true if the given object is empty, false otherwise.\r\n * @param obj The Object.\r\n */\r\nexport function isEmptyObject(obj: any): boolean {\r\n    for (let name in obj)\r\n        return false;\r\n    return true;\r\n};","import { isArrayLike } from 'core/utils/types';\r\nimport { PlainObject } from 'core/typings';\r\n\r\n\r\n/**\r\n * Iterates through a array or object\r\n * @param arrayLikeOrObject The array or object through which shall be iterated.\r\n * @param callback The function which is responsible for the iteration. \r\n * If the function returns true its treated like a \"continue\" statement.\r\n * If the function returns false its treated like a \"break\" statement.\r\n */\r\nexport function each<T>(array: Array<T> | ReadonlyArray<T>, callback: (value: T, indexOrKey: number, source: Array<T>) => boolean | void): Array<T> | ReadonlyArray<T>;\r\nexport function each<T>(array: Array<T> | ReadonlyArray<T> | null, callback: (value: T, indexOrKey: number, source: Array<T>) => boolean | void): Array<T> | ReadonlyArray<T> | null;\r\nexport function each<T>(arrayLikeObject: ArrayLike<T>, callback: (value: T, indexOrKey: number, source: ArrayLike<T>) => boolean | void): ArrayLike<T>;\r\nexport function each<T>(arrayLikeObject: ArrayLike<T> | null, callback: (value: T, indexOrKey: number, source: ArrayLike<T>) => boolean | void): ArrayLike<T> | null;\r\nexport function each(obj: PlainObject, callback: (value: any, indexOrKey: string, source: PlainObject) => boolean | void): PlainObject;\r\nexport function each(obj: PlainObject | null, callback: (value: any, indexOrKey: string, source: PlainObject) => boolean | void): PlainObject | null;\r\nexport function each<T>(source: ArrayLike<T> | PlainObject | null, callback: (value: T | any, indexOrKey: any, source: any) => boolean | void): Array<T> | ReadonlyArray<T> | ArrayLike<T> | PlainObject | null {\r\n    let i: number | string = 0;\r\n\r\n    if (isArrayLike(source)) {\r\n        for (; i < source.length; i++) {\r\n            if (callback(source[i], i, source) === false)\r\n                break;\r\n        }\r\n    }\r\n    else if (source) {\r\n        for (i in source) {\r\n            if (callback(source[i], i, source) === false)\r\n                break;\r\n        }\r\n    }\r\n    return source;\r\n};\r\n\r\n/**\r\n * Returns the index of the given inside the given array or -1 if the given item isn't part of the given array.\r\n * @param arr The array.\r\n * @param item The item.\r\n * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\r\n */\r\nexport const indexOf: <T = any>(arr: Array<T>, item: T, fromIndex?: number) => number = (arr, item, fromIndex) => {\r\n    return arr.indexOf(item, fromIndex);\r\n}","import { isArrayLike, isHTMLElement } from 'core/utils/types';\r\nimport { each } from 'core/utils/arrays';\r\nimport { parent } from 'core/dom/traversal';\r\n\r\ntype NodeCollection = ArrayLike<Node> | Node | undefined | null;\r\n\r\n/**\r\n * Inserts Nodes before the given preferredAnchor element.\r\n * @param parent The parent of the preferredAnchor element or the element which shall be the parent of the inserted Nodes.\r\n * @param preferredAnchor The element before which the Nodes shall be inserted or null if the elements shall be appended at the end.\r\n * @param insertedElms The Nodes which shall be inserted.\r\n */\r\nconst before: (parent: Node | null, preferredAnchor: Node | null, insertedElms: NodeCollection) => void = (parent, preferredAnchor, insertedElms) => {\r\n    if (insertedElms) {\r\n        let anchor: Node | null = preferredAnchor;\r\n        let fragment: DocumentFragment | Node | undefined | null;\r\n\r\n        // parent must be defined\r\n        if (parent) {\r\n            if (isArrayLike(insertedElms)) {\r\n                fragment = document.createDocumentFragment();\r\n\r\n                // append all insertedElms to the fragment and if one of these is the anchor, change the anchor\r\n                each(insertedElms, (insertedElm) => {\r\n                    if (insertedElm === anchor) {\r\n                        anchor = insertedElm.previousSibling;\r\n                    }\r\n                    fragment!.appendChild(insertedElm);\r\n                });\r\n            }\r\n            else {\r\n                fragment = insertedElms;\r\n            }\r\n\r\n            // if the preferred anchor isn't null set it to a valid anchor\r\n            if (preferredAnchor) {\r\n                if (!anchor) {\r\n                    anchor = parent.firstChild;\r\n                }\r\n                else if (anchor !== preferredAnchor) {\r\n                    anchor = anchor.nextSibling;\r\n                }\r\n            }\r\n\r\n            parent.insertBefore(fragment, anchor);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Appends the given children at the end of the given Node.\r\n * @param node The Node to which the children shall be appended.\r\n * @param children The Nodes which shall be appended.\r\n */\r\nexport const appendChildren: (node: Node | null, children: NodeCollection) => void = (node, children) => { before(node, null, children) };\r\n\r\n/**\r\n * Prepends the given children at the start of the given Node.\r\n * @param node The Node to which the children shall be prepended.\r\n * @param children The Nodes which shall be prepended.\r\n */\r\nexport const prependChildren: (node: Node | null, children: NodeCollection) => void = (node, children) => { before(node, node && node.firstChild, children) };\r\n\r\n/**\r\n * Inserts the given Nodes before the given Node.\r\n * @param node The Node before which the given Nodes shall be inserted.\r\n * @param insertedNodes The Nodes which shall be inserted.\r\n */\r\nexport const insertBefore: (node: Node | null, insertedNodes: NodeCollection) => void = (node, insertedNodes) => { before(parent(node), node, insertedNodes) };\r\n\r\n/**\r\n * Inserts the given Nodes after the given Node.\r\n * @param node The Node after which the given Nodes shall be inserted.\r\n * @param insertedNodes The Nodes which shall be inserted.\r\n */\r\nexport const insertAfter: (node: Node | null, insertedNodes: NodeCollection) => void = (node, insertedNodes) => { before(parent(node), node && node.nextSibling, insertedNodes) };\r\n\r\n/**\r\n * Removes the given Nodes from their parent.\r\n * @param nodes The Nodes which shall be removed.\r\n */\r\nexport const removeElements: (nodes: NodeCollection) => void = (nodes) => {\r\n    if (isArrayLike(nodes)) {\r\n        each(Array.from(nodes), (e) => removeElements(e));\r\n    }\r\n    else if (nodes) {\r\n        const parentNode = nodes.parentNode;\r\n        if (parentNode)\r\n            parentNode.removeChild(nodes);\r\n    }\r\n}","import { each } from 'core/utils/arrays';\r\nimport { contents } from 'core/dom/traversal';\r\nimport { removeElements } from 'core/dom/manipulation';\r\n\r\nexport const createDiv: () => HTMLDivElement = () => {\r\n    return document.createElement('div');\r\n}\r\n\r\nexport const createDOM: (html: string) => ReadonlyArray<Node> = (html) => {\r\n    const elm = createDiv();\r\n    elm.innerHTML = html.trim();\r\n\r\n    return each(contents(elm), (elm) => removeElements(elm));\r\n}","import { each } from 'core/utils/arrays';\r\n\r\nconst elementIsVisible: (elm: HTMLElement) => boolean = (elm) => {\r\n    return !!(elm.offsetWidth || elm.offsetHeight || elm.getClientRects().length);\r\n}\r\n\r\nexport const find: (selector: string, elm?: Element | null) => ReadonlyArray<Element> = (selector, elm?) => {\r\n    const arr: Array<Element> = [];\r\n\r\n    each((elm || document).querySelectorAll(selector), (e: Element) => {\r\n        arr.push(e);\r\n    });\r\n\r\n    return arr;\r\n}\r\n\r\nexport const findFirst: (selector: string, elm?: Element | null) => Element | null = (selector, elm?) => {\r\n    return (elm || document).querySelector(selector);\r\n}\r\n\r\nexport const is: (elm: Element | null, selector: string) => boolean = (elm, selector) => {\r\n    if (elm) {\r\n        if (selector === ':visible')\r\n            return elementIsVisible(elm as HTMLElement);\r\n        if (selector === ':hidden')\r\n            return !elementIsVisible(elm as HTMLElement);\r\n        if (elm.matches(selector))\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport const children: (elm: Element | null, selector?: string) => ReadonlyArray<Element> = (elm, selector?) => {\r\n    const children: Array<Element> = [];\r\n\r\n    each(elm && elm.children, (child: Element) => {\r\n        if (selector) {\r\n            if (child.matches(selector))\r\n                children.push(child);\r\n        }\r\n        else\r\n            children.push(child);\r\n    });\r\n\r\n    return children;\r\n}\r\n\r\nexport const contents: (elm: Element | null) => ReadonlyArray<ChildNode> = (elm) => {\r\n    return elm ? Array.from<ChildNode>(elm.childNodes) : [];\r\n}\r\n\r\nexport const parent: (elm: Node | null) => Node | null = (elm) => elm ? elm.parentElement : null;","import { each } from 'core/utils';\r\nimport { createDiv } from 'core/dom';\r\n\r\nconst firstLetterToUpper: (str: string) => string = (str) => {\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n}\r\nconst getDummyStyle: () => CSSStyleDeclaration = () => {\r\n    return createDiv().style;\r\n}\r\n\r\n//https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix\r\n\r\nexport const cssPrefixes: ReadonlyArray<string> = ['-webkit-', '-moz-', '-o-', '-ms-'];\r\nexport const jsPrefixes: ReadonlyArray<string> = ['WebKit', 'Moz', 'O', 'MS', 'webkit', 'moz', 'o', 'ms'];\r\n\r\nexport const jsCache: { [key: string]: any } = {};\r\nexport const cssCache: { [key: string]: string } = {};\r\n\r\n/**\r\n * Gets the name of the given CSS property with vendor prefix if it isn't supported without, or undefined if unsupported.\r\n * @param name The name of the CSS property which shall be get.\r\n */\r\nexport const cssProperty: (name: string) => string | undefined = (name) => {\r\n    let result: string | undefined = cssCache[name];\r\n\r\n    if (cssCache.hasOwnProperty(name))\r\n        return result;\r\n\r\n    const uppercasedName: string = firstLetterToUpper(name);\r\n    const elmStyle: CSSStyleDeclaration = getDummyStyle();\r\n\r\n    each(cssPrefixes, (prefix: string) => {\r\n        const prefixWithoutDashes: string = prefix.replace(/-/g, '');\r\n        const resultPossibilities: Array<string> = [\r\n            name, //transition\r\n            prefix + name, //-webkit-transition\r\n            prefixWithoutDashes + uppercasedName, //webkitTransition\r\n            firstLetterToUpper(prefixWithoutDashes) + uppercasedName //WebkitTransition\r\n        ];\r\n        result = resultPossibilities.find((resultPossibility: string) => elmStyle[resultPossibility] !== undefined);\r\n        return !result;\r\n    });\r\n\r\n    cssCache[name] = result;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Get the name of the given CSS property value(s), with vendor prefix if it isn't supported wuthout, or undefined if no value is supported. \r\n * @param property The CSS property to which the CSS property value(s) belong.\r\n * @param values The value(s) separated by spaces which shall be get.\r\n * @param suffix A suffix which is added to each value in case the value is a function or something else more advanced.\r\n */\r\nexport const cssPropertyValue: (property: string, values: string, suffix?: string) => string | undefined = (property, values, suffix) => {\r\n    const name: string = property + ' ' + values;\r\n    let result: string | undefined = cssCache[name];\r\n\r\n    if (cssCache.hasOwnProperty(name))\r\n        return result;\r\n\r\n    const dummyStyle: CSSStyleDeclaration = getDummyStyle();\r\n    const possbleValues: Array<string> = values.split(' ');\r\n    const preparedSuffix: string = suffix || '';\r\n    const cssPrefixesWithFirstEmpty = [''].concat(cssPrefixes);\r\n\r\n    each(possbleValues, (possibleValue: string) => {\r\n        each(cssPrefixesWithFirstEmpty, (prefix: string) => {\r\n            const prop = prefix + possibleValue;\r\n            dummyStyle.cssText = property + ':' + prop + preparedSuffix;\r\n            if (dummyStyle.length) {\r\n                result = prop;\r\n                return false;\r\n            }\r\n        });\r\n        return !result;\r\n    });\r\n\r\n    cssCache[name] = result;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Get the requested JS function, object or constructor with vendor prefix if it isn't supported without or undefined if unsupported.\r\n * @param name The name of the JS function, object or constructor.\r\n */\r\nexport const jsAPI: (name: string) => any = (name) => {\r\n    let result: any = jsCache[name] || window[name];\r\n\r\n    if (jsCache.hasOwnProperty(name))\r\n        return result;\r\n\r\n    each(jsPrefixes, (prefix: string) => {\r\n        result = result || window[prefix + firstLetterToUpper(name)];\r\n        return !result;\r\n    });\r\n\r\n    jsCache[name] = result;\r\n    return result;\r\n}\r\n","import { each, indexOf } from 'core/utils/arrays';\r\nimport { type, isArray, isUndefined, isEmptyObject, isPlainObject, isString } from 'core/utils/types';\r\nimport { PlainObject, OptionsTemplate, OptionsTemplateTypes, OptionsTemplateType, OptionsValidated, Func, OptionsValidatedResult } from 'core/typings';\r\n\r\nconst stringify = JSON.stringify;\r\n\r\n/**\r\n * A prefix and suffix tuple which serves as recognition pattern for template types.\r\n */\r\nconst templateTypePrefixSuffix: readonly [string, string] = ['__TPL_', '_TYPE__'];\r\n/**\r\n * A object which serves as a mapping for \"normal\" types and template types.\r\n * Key   = normal type string\r\n * value = template type string\r\n */\r\nconst optionsTemplateTypes: OptionsTemplateTypesDictionary = [\r\n    'boolean',\r\n    'number',\r\n    'string',\r\n    'array',\r\n    'object',\r\n    'function',\r\n    'null'\r\n].reduce((result, item) => {\r\n    result[item] = templateTypePrefixSuffix[0] + item + templateTypePrefixSuffix[1];\r\n    return result;\r\n}, {} as OptionsTemplateTypesDictionary);\r\n\r\n/**\r\n * Validates the given options object according to the given template object and returns a object which looks like:\r\n * {\r\n *  foreign   : a object which consists of properties which aren't defined inside the template. (foreign properties)\r\n *  validated : a object which consists only of valid properties. (property name is inside the template and value has a correct type)\r\n * }\r\n * @param options The options object which shall be validated.\r\n * @param template The template according to which the options object shall be validated.\r\n * @param optionsDiff When provided the returned validated object will only have properties which are different to this objects properties.\r\n * Example (assume all properties are valid to the template): \r\n * Options object            : { a: 'a', b: 'b', c: 'c' }\r\n * optionsDiff object        : { a: 'a', b: 'b', c: undefined }\r\n * Returned validated object : { c: 'c' }\r\n * Because the value of the properties a and b didn't change, they aren't included in the returned object.\r\n * Without the optionsDiff object the returned validated object would be: { a: 'a', b: 'b', c: 'c' }\r\n * @param doWriteErrors True if errors shall be logged into the console, false otherwise.\r\n * @param propPath The propertyPath which lead to this object. (used for error logging)\r\n */\r\nconst validateRecursive = function <T extends PlainObject>(options: T, template: OptionsTemplate<Required<T>>, optionsDiff: OptionsValidated<T>, doWriteErrors?: boolean, propPath?: string): OptionsValidatedResult<T> {\r\n    const validatedOptions: OptionsValidated<T> = {};\r\n    const optionsCopy: T = Object.assign({}, options);\r\n    const props = Object.keys(template).filter(prop => options.hasOwnProperty(prop));\r\n\r\n    each(props, (prop: Extract<keyof T, string>) => {\r\n        const optionsDiffValue: any = isUndefined(optionsDiff[prop]) ? {} : optionsDiff[prop];\r\n        const optionsValue: any = options[prop];\r\n        const templateValue: PlainObject | string | OptionsTemplateTypes | Array<OptionsTemplateTypes> = template[prop];\r\n        const templateIsComplex = isPlainObject(templateValue);\r\n        const propPrefix = propPath ? propPath + '.' : '';\r\n\r\n        //if the template has a object as value, it means that the options are complex (verschachtelt)\r\n        if (templateIsComplex && isPlainObject(optionsValue)) {\r\n            const validatedResult = validateRecursive(optionsValue, templateValue as PlainObject, optionsDiffValue, doWriteErrors, propPrefix + prop);\r\n            validatedOptions[prop] = validatedResult.validated;\r\n            optionsCopy[prop] = validatedResult.foreign as any;\r\n\r\n            each([optionsCopy, validatedOptions], (value) => {\r\n                if (isEmptyObject(value[prop])) {\r\n                    delete value[prop];\r\n                }\r\n            });\r\n        }\r\n        else if (!templateIsComplex) {\r\n            let isValid = false;\r\n            const errorEnumStrings: Array<string> = [];\r\n            const errorPossibleTypes: Array<string> = [];\r\n            const optionsValueType = type(optionsValue);\r\n            const templateValueArr: Array<string | OptionsTemplateTypes> = !isArray(templateValue) ? [templateValue as string | OptionsTemplateTypes] : templateValue as Array<OptionsTemplateTypes>;\r\n\r\n            each(templateValueArr, (currTemplateType) => {\r\n                //if currType value isn't inside possibleTemplateTypes we assume its a enum string value\r\n                const isEnumString = indexOf(Object.values(optionsTemplateTypes), currTemplateType) < 0;\r\n                if (isEnumString && isString(optionsValue)) {\r\n                    //split it into a array which contains all possible values for example: [\"yes\", \"no\", \"maybe\"]\r\n                    const enumStringSplit = currTemplateType.split(' ');\r\n                    isValid = !!enumStringSplit.find(possibility => possibility === optionsValue);\r\n\r\n                    // build error message\r\n                    errorEnumStrings.push(...enumStringSplit);\r\n                }\r\n                else {\r\n                    isValid = optionsTemplateTypes[optionsValueType] === currTemplateType;\r\n                }\r\n\r\n                // build error message\r\n                errorPossibleTypes.push(isEnumString ? optionsTemplateTypes.string : currTemplateType);\r\n\r\n                // continue if invalid, break if valid\r\n                return !isValid;\r\n            });\r\n\r\n\r\n            if (isValid) {\r\n                const doStringifyComparison = isArray(optionsValue) || isPlainObject(optionsValue);\r\n                if (doStringifyComparison ? stringify(optionsValue) !== stringify(optionsDiffValue) : optionsValue !== optionsDiffValue) {\r\n                    validatedOptions[prop] = optionsValue;\r\n                }\r\n            }\r\n            else if (doWriteErrors) {\r\n                console.warn(`The option \"${propPrefix}${prop}\" wasn't set, because it doesn't accept the type [ ${optionsValueType.toUpperCase()} ] with the value of \"${optionsValue}\".\\r\\n` +\r\n                    `Accepted types are: [ ${errorPossibleTypes.join(', ').toUpperCase()} ].\\r\\n` +\r\n                    (errorEnumStrings.length > 0 ? `\\r\\nValid strings are: [ ${errorEnumStrings.join(', ')} ].` : ''))\r\n            }\r\n\r\n            delete optionsCopy[prop];\r\n        }\r\n    });\r\n\r\n    return {\r\n        foreign: optionsCopy,\r\n        validated: validatedOptions\r\n    };\r\n};\r\n\r\n/**\r\n * Validates the given options object according to the given template object and returns a object which looks like:\r\n * {\r\n *  foreign   : a object which consists of properties which aren't defined inside the template. (foreign properties)\r\n *  validated : a object which consists only of valid properties. (property name is inside the template and value has a correct type)\r\n * }\r\n * @param options The options object which shall be validated.\r\n * @param template The template according to which the options object shall be validated.\r\n * @param optionsDiff When provided the returned validated object will only have properties which are different to this objects properties.\r\n * Example (assume all properties are valid to the template): \r\n * Options object            : { a: 'a', b: 'b', c: 'c' }\r\n * optionsDiff object        : { a: 'a', b: 'b', c: undefined }\r\n * Returned validated object : { c: 'c' }\r\n * Because the value of the properties a and b didn't change, they aren't included in the returned object.\r\n * Without the optionsDiff object the returned validated object would be: { a: 'a', b: 'b', c: 'c' }\r\n * @param doWriteErrors True if errors shall be logged into the console, false otherwise.\r\n */\r\nconst validate = function <T extends PlainObject>(options: T, template: OptionsTemplate<Required<T>>, optionsDiff?: OptionsValidated<T>, doWriteErrors?: boolean): OptionsValidatedResult<T> {\r\n    /*\r\n    if (!isEmptyObject(foreign) && doWriteErrors)\r\n        console.warn(`The following options are discarded due to invalidity:\\r\\n ${window.JSON.stringify(foreign, null, 2)}`);\r\n\r\n    \r\n    //add values, which aren't specified in the template, to the finished validated object to prevent them from being discarded\r\n    if (keepForeignProps) {\r\n        Object.assign(result.validated, foreign);\r\n    }\r\n    */\r\n    return validateRecursive(options, template, optionsDiff || {}, doWriteErrors || false);\r\n};\r\n\r\nexport { validate, optionsTemplateTypes };\r\n\r\ntype OptionsTemplateTypesDictionary = {\r\n    readonly boolean: OptionsTemplateType<boolean>;\r\n    readonly number: OptionsTemplateType<number>;\r\n    readonly string: OptionsTemplateType<string>;\r\n    readonly array: OptionsTemplateType<Array<any>>;\r\n    readonly object: OptionsTemplateType<object>;\r\n    readonly function: OptionsTemplateType<Func>;\r\n    readonly null: OptionsTemplateType<null>;\r\n}\r\n","import { jsAPI } from 'core/compatibility/vendors';\r\n\r\nexport const resizeObserver: any | undefined = jsAPI('ResizeObserver');","const targets: Set<Element> = new Set();\r\nconst targetInstanceMap: WeakMap<Element, any> = new WeakMap();\r\n\r\n/**\r\n * Adds the given OverlayScrollbars instance to the given element.\r\n * @param target The element which is the target of the OverlayScrollbars instance.\r\n * @param osInstance The OverlayScrollbars instance.\r\n */\r\nexport const addInstance: (target: Element, osInstance: any) => void = (target, osInstance) => {\r\n    targetInstanceMap.set(target, osInstance);\r\n    targets.add(target);\r\n}\r\n\r\n/**\r\n * Removes a OverlayScrollbars instance from the given element.\r\n * @param target The element from which its OverlayScrollbars instance shall be removed.\r\n */\r\nexport const removeInstance: (target: Element) => void = (target) => {\r\n    targetInstanceMap.delete(target);\r\n    targets.delete(target);\r\n}\r\n\r\n/**\r\n * Gets the OverlayScrollbars from the given element or undefined if it doesn't have one.\r\n * @param target The element of which its OverlayScrollbars instance shall be get.\r\n */\r\nexport const getInstance: (target: Element) => any = (target) => {\r\n    return targetInstanceMap.get(target);\r\n}\r\n\r\n/**\r\n * Gets a Map which represents all active OverayScrollbars instances. \r\n * The Key is the ekement and the value is the instance.\r\n */\r\nexport const allInstances: () => ReadonlyMap<Element, any> = () => {\r\n    const validTargetInstanceMap: Map<Element, any> = new Map();\r\n\r\n    targets.forEach((target: Element) => {\r\n        /* istanbul ignore else */\r\n        if (targetInstanceMap.has(target)) {\r\n            validTargetInstanceMap.set(target, targetInstanceMap.get(target))\r\n        }\r\n    });\r\n\r\n    targets.clear();\r\n\r\n    validTargetInstanceMap.forEach((instance: any, validTarget: Element) => {\r\n        targets.add(validTarget);\r\n    });\r\n\r\n    return validTargetInstanceMap;\r\n}","\r\nimport { createDOM } from 'core/dom';\r\n\r\nexport * from 'core/compatibility';\r\nexport * from 'core/utils';\r\nexport * from 'core/dom';\r\nexport * from 'core/options';\r\nexport * from 'instances';\r\n\r\n\r\n\r\nexport default () => createDOM(`\\\r\n    <div class=\"os-host\">\\\r\n        <div class=\"os-resize-observer-host\"></div>\\\r\n        <div class=\"os-padding\">\\\r\n            <div class=\"os-viewport\">\\\r\n                <div class=\"os-content\">\\\r\n                    fdfhdfgh\\\r\n                </div>\\\r\n            </div>\\\r\n        </div>\\\r\n        <div class=\"os-scrollbar os-scrollbar-horizontal\">\\\r\n            <div class=\"os-scrollbar-track\">\\\r\n                <div class=\"os-scrollbar-handle\"></div>\\\r\n            </div>\\\r\n        </div>\\\r\n        <div class=\"os-scrollbar os-scrollbar-vertical\">\\\r\n            <div class=\"os-scrollbar-track\">\\\r\n                <div class=\"os-scrollbar-handle\"></div>\\\r\n            </div>\\\r\n        </div>\\\r\n        <div class=\"os-scrollbar-corner\"></div>\\\r\n    </div>`);","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(95);\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }"],"sourceRoot":""}